<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Sports Search Trends</title>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
				background: #ffffff;
				color: #1f2937;
				font-family: "Inter", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
			}

			body {
				display: flex;
				justify-content: center;
				padding: clamp(3rem, 7vw, 6rem) clamp(1.5rem, 4vw, 3rem);
				background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
			}

			.page {
				width: min(1400px, 98vw);
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: clamp(6rem, 10vw, 9rem);
			}

			.chart-frame {
				width: 100%;
				background: #f9fafb;
				border: 1px solid #e2e8f0;
				box-shadow: 0 12px 28px rgba(15, 23, 42, 0.08);
				padding: clamp(1rem, 3vw, 1.5rem);
				border-radius: 18px;
			}

			.chart-frame svg {
				width: 100%;
				display: block;
			}

			#line-chart {
				height: min(680px, 80vh);
			}

			#grid-chart {
				height: min(420px, 60vh);
			}

			#doodle-chart {
				height: min(420px, 60vh);
			}

			.doodle-frame {
				will-change: transform, opacity;
			}

			.fillable-region {
				cursor: pointer;
				transition: fill 0.25s ease;
			}

			.axis path,
			.axis line {
				stroke: rgba(148, 163, 184, 0.4);
			}

			.axis text {
				fill: #334155;
				font-size: 0.85rem;
			}

			.axis-label {
				fill: #475569;
				font-size: 0.9rem;
				letter-spacing: 0.04em;
			}

			.line {
				fill: none;
				stroke-linejoin: round;
				stroke-linecap: round;
				stroke-width: 1.8;
				stroke-opacity: 0.9;
				transition: stroke-opacity 0.2s ease, stroke-width 0.2s ease;
			}

			.area {
				stroke: none;
				fill-opacity: 0;
				transition: fill-opacity 0.2s ease;
			}

			.legend text {
				fill: #1f2937;
				font-size: 0.95rem;
				cursor: pointer;
				transition: fill 0.2s ease;
			}

			.legend text:hover,
			.legend text:focus-visible {
				fill: #0f172a;
			}

			.legend-line {
				stroke-width: 3;
				stroke-linecap: round;
			}

			.legend-item {
				outline: none;
			}

			.hover-target {
				fill: none;
				stroke: transparent;
				stroke-width: 24;
				cursor: pointer;
			}

			.grid-line {
				stroke: rgba(148, 163, 184, 0.35);
				stroke-width: 1;
			}

			.connection-line {
				stroke: #111827;
				stroke-width: 2;
				stroke-linecap: round;
			}

			.connection-line.active {
				stroke-width: 3.5;
			}

			.arrow-line {
				fill: none;
				stroke-width: 2.5;
				stroke-dasharray: 8 6;
			}

			.grid-node {
				fill: #2563eb;
				stroke: #0f172a;
				stroke-width: 2;
				transition: transform 0.2s ease, fill 0.2s ease;
				cursor: pointer;
			}

			.grid-node.active {
				fill: #1d4ed8;
				transform: scale(1.1);
			}

			.grid-label {
				fill: #1f2937;
				font-weight: 600;
				font-size: 0.9rem;
			}

			.grid-label.active {
				fill: #1d4ed8;
			}
		</style>
	</head>
	<body>
		<div class="page">
			<div class="chart-frame">
				<svg id="line-chart" role="img" aria-label="Weekly search interest by league"></svg>
			</div>
			<div class="chart-frame">
				<svg
					id="grid-chart"
					role="img"
					aria-label="Grid network view of energy states"
				></svg>
			</div>
			<div class="chart-frame doodle-frame">
				<svg
					id="doodle-chart"
					role="img"
					aria-label="Interactive DoodleBob sketch"
				></svg>
			</div>
		</div>

		<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
		<script>
			/* 
			My initial prompt was: 
			Make a histogram using HTML, CSS, D3.JS that will get posted online through github actions. sportsdata.csv has the data that must be used.
			This took a very long time to load and provided a complicated graph with too much data, hence I added a new prompt to edit the existing code and remove unneccessary details.):
            I just need a chart that includes all of the data sets (f1, nba, nfll, premierLeague) instead of a bar chart, do a line chart that becomes an area graph when you hover the cursor over the specific data set. Do not add extra text, just keep the graph and its axis and data set
			*/
			(function () {
				const svg = d3.select("#line-chart");
				const width = 1300;
				const height = 640;
				const margin = { top: 64, right: 220, bottom: 80, left: 72 };
				const plotWidth = width - margin.left - margin.right;
				const plotHeight = height - margin.top - margin.bottom;

				const parseDate = d3.timeParse("%Y-%m-%d");

				const seriesDefinitions = [
					{ key: "f1", label: "F1", column: "f1: (Worldwide)" },
					{ key: "nba", label: "NBA", column: "nba: (Worldwide)" },
					{ key: "nfl", label: "NFL", column: "nfl: (Worldwide)" },
					{ key: "premierLeague", label: "Premier League", column: "Premier League: (Worldwide)" }
				];

				const parseValue = (value) => {
					const numeric = Number(value);
					return Number.isFinite(numeric) ? numeric : NaN;
				};

				const color = d3
					.scaleOrdinal()
					.domain(seriesDefinitions.map((d) => d.key))
					.range(["#1f77b4", "#d62728", "#2ca02c", "#ff7f0e"]);

				const definedValue = (d) => Number.isFinite(d.value);

				svg.attr("viewBox", `0 0 ${width} ${height}`).attr("preserveAspectRatio", "xMidYMid meet");

				const root = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
				const defs = svg.append("defs");
				const clipPathId = "line-chart-clip";
				const clipRect = defs
					.append("clipPath")
					.attr("id", clipPathId)
					.append("rect")
					.attr("x", 0)
					.attr("y", plotHeight)
					.attr("width", plotWidth)
					.attr("height", 0);

				const xScale = d3.scaleTime().range([0, plotWidth]);
				const yScale = d3.scaleLinear().range([plotHeight, 0]);

				const lineBuilder = d3
					.line()
					.defined(definedValue)
					.x((d) => xScale(d.date))
					.y((d) => yScale(d.value));

				const areaBuilder = d3
					.area()
					.defined(definedValue)
					.x((d) => xScale(d.date))
					.y0(plotHeight)
					.y1((d) => yScale(d.value));

				const areasLayer = root.append("g");
				const linesLayer = root.append("g");
				const hitLayer = root.append("g");

				const xAxisGroup = root
					.append("g")
					.attr("class", "axis axis--x")
					.attr("transform", `translate(0,${plotHeight})`);

				const yAxisGroup = root.append("g").attr("class", "axis axis--y");

				root
					.append("text")
					.attr("class", "axis-label")
					.attr("x", plotWidth / 2)
					.attr("y", plotHeight + margin.bottom - 28)
					.attr("text-anchor", "middle")
					.text("Week");

				root
					.append("text")
					.attr("class", "axis-label")
					.attr("x", -margin.left + 18)
					.attr("y", -28)
					.attr("text-anchor", "start")
					.text("Search interest");

				const legend = svg
					.append("g")
					.attr("class", "legend")
					.attr("transform", `translate(${width - margin.right + 30},${margin.top})`);

				let areaPaths;
				let linePaths;

				function cleanCsvLines(rawText) {
					const lines = rawText.split(/\r?\n/).filter((line) => line.trim().length > 0);
					const headerIndex = lines.findIndex((line) => line.startsWith("Week,"));
					if (headerIndex === -1) {
						throw new Error("Unable to locate CSV header in sportsdata.csv");
					}
					return lines.slice(headerIndex).join("\n");
				}

				function setActiveSeries(key) {
					if (!linePaths || !areaPaths) return;
					const hasKey = Boolean(key);
					linePaths
						.attr("stroke-opacity", (d) => (hasKey && d.key !== key ? 0.25 : 0.95))
						.attr("stroke-width", (d) => (hasKey && d.key === key ? 2.7 : 1.8));
					areaPaths.style("fill-opacity", (d) => (hasKey && d.key === key ? 0.4 : 0));
				}

				function resetActiveSeries() {
					setActiveSeries(null);
				}

				function handleLegendKeyboard(event, key) {
					if (event.key === "Enter" || event.key === " ") {
						event.preventDefault();
						setActiveSeries(key);
					} else if (event.key === "Escape") {
						resetActiveSeries();
					}
				}

				d3.text("sportsdata.csv")
					.then((rawText) => {
						const cleanCsv = cleanCsvLines(rawText);
						const parsedRows = d3
							.csvParse(cleanCsv, (row) => ({
								Week: parseDate(row.Week.trim()),
								"f1: (Worldwide)": parseValue(row["f1: (Worldwide)"]),
								"nba: (Worldwide)": parseValue(row["nba: (Worldwide)"]),
								"nfl: (Worldwide)": parseValue(row["nfl: (Worldwide)"]),
								"Premier League: (Worldwide)": parseValue(row["Premier League: (Worldwide)"])
							}))
							.filter((row) => row.Week instanceof Date && !Number.isNaN(row.Week.getTime()));

						if (!parsedRows.length) {
							return;
						}

						const seriesData = seriesDefinitions.map((definition) => ({
							...definition,
							values: parsedRows.map((row) => ({
								date: row.Week,
								value: Number.isFinite(row[definition.column]) ? row[definition.column] : NaN
							}))
						}));

						const xDomain = d3.extent(parsedRows, (d) => d.Week);
						xScale.domain(xDomain);

						const allValues = seriesData
							.flatMap((series) => series.values.map((d) => d.value))
							.filter((value) => Number.isFinite(value));
						const yMax = d3.max(allValues) || 1;
						yScale.domain([0, yMax]).nice();

						const xAxis = d3
							.axisBottom(xScale)
							.ticks(Math.min(12, Math.ceil(parsedRows.length / 8)))
							.tickSizeOuter(0);
						const yAxis = d3.axisLeft(yScale).ticks(6).tickSizeOuter(0);

						xAxisGroup.call(xAxis);
						yAxisGroup.call(yAxis);

						areaPaths = areasLayer
							.selectAll("path.area")
							.data(seriesData, (d) => d.key)
							.join("path")
							.attr("class", "area")
							.attr("fill", (d) => color(d.key))
							.attr("d", (d) => areaBuilder(d.values))
							.attr("clip-path", `url(#${clipPathId})`);

						linePaths = linesLayer
							.selectAll("path.line")
							.data(seriesData, (d) => d.key)
							.join("path")
							.attr("class", "line")
							.attr("stroke", (d) => color(d.key))
							.attr("d", (d) => lineBuilder(d.values))
							.attr("clip-path", `url(#${clipPathId})`);

						clipRect
							.transition()
							.duration(1200)
							.ease(d3.easeCubicOut)
							.attr("y", 0)
							.attr("height", plotHeight);

						hitLayer
							.selectAll("path.hover-target")
							.data(seriesData, (d) => d.key)
							.join("path")
							.attr("class", "hover-target")
							.attr("d", (d) => lineBuilder(d.values))
							.attr("tabindex", 0)
							.on("mouseenter focus", (event, d) => setActiveSeries(d.key))
							.on("mouseleave blur", resetActiveSeries)
							.on("keydown", (event, d) => handleLegendKeyboard(event, d.key));

						const legendItems = legend
							.selectAll("g.legend-item")
							.data(seriesData, (d) => d.key)
							.join((enter) => {
								const g = enter
									.append("g")
									.attr("class", "legend-item")
									.attr("tabindex", 0);

								g.append("line")
									.attr("class", "legend-line")
									.attr("x1", 0)
									.attr("x2", 28)
									.attr("y1", 0)
									.attr("y2", 0);

								g.append("text")
									.attr("x", 36)
									.attr("y", 0)
									.attr("dominant-baseline", "middle");

								return g;
							});

						legendItems
							.attr("transform", (d, i) => `translate(0, ${i * 28})`)
							.select("line.legend-line")
							.attr("stroke", (d) => color(d.key));

						legendItems
							.select("text")
							.text((d) => d.label);

						legendItems
							.on("mouseenter focus", (event, d) => setActiveSeries(d.key))
							.on("mouseleave blur", resetActiveSeries)
							.on("keydown", (event, d) => handleLegendKeyboard(event, d.key));

						resetActiveSeries();
						svg.on("mouseleave", resetActiveSeries);
					})
					.catch((error) => {
						console.error(error);
					});
			})();
            
			/*
			I spaced out the graphs more like this. also made the transition work better:
			the 2 graphs are too close to each other, causing the transition to activate too early. move the 2 graphs away from each other, and make the transition position dependent - i.e. start when the graph comes in to view and finish when it's fully in view.
			*/

			(function () {
				const columns = 5;
				const rows = 12;
				const width = 1220;
				const height = 400;
				const margin = { top: 36, right: 200, bottom: 42, left: 80 };
				const plotWidth = width - margin.left - margin.right;
				const plotHeight = height - margin.top - margin.bottom;

				const svg = d3
					.select("#grid-chart")
					.attr("viewBox", `0 0 ${width} ${height}`)
					.attr("preserveAspectRatio", "xMidYMid meet");

				const root = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

				const cellWidth = plotWidth / (columns - 1);
				const cellHeight = plotHeight / (rows - 1);

				const nodes = [
					{ id: "ea2", label: "eᵃ₂", col: 2, row: 3 },
					{ id: "ea1", label: "eᵃ₁", col: 2, row: 8 },
					{ id: "eb2", label: "eᵇ₂", col: 4, row: 4 },
					{ id: "eb1", label: "eᵇ₁", col: 4, row: 6 }
				].map((node) => ({
					...node,
					x: (node.col - 1) * cellWidth,
					y: (node.row - 1) * cellHeight
				}));

				const connections = [
					{ source: "ea2", target: "ea1" },
					{ source: "ea2", target: "eb2" },
					{ source: "eb1", target: "ea1" },
					{ source: "eb1", target: "eb2" }
				];

				const arrows = [
					{ source: "ea2", target: "eb1", color: "#60a5fa" },
					{ source: "ea1", target: "eb2", color: "#1e3a8a" }
				];

				const markers = svg.append("defs");

				arrows.forEach((arrow, index) => {
					markers
						.append("marker")
						.attr("id", `arrow-head-${index}`)
						.attr("viewBox", "0 -4 8 8")
						.attr("refX", 8)
						.attr("refY", 0)
						.attr("markerWidth", 8)
						.attr("markerHeight", 8)
						.attr("orient", "auto")
						.append("path")
						.attr("d", "M0,-4L8,0L0,4")
						.attr("fill", arrow.color);
				});

				root
					.selectAll("line.grid-line.horizontal")
					.data(d3.range(rows))
					.join("line")
					.attr("class", "grid-line horizontal")
					.attr("x1", 0)
					.attr("x2", plotWidth)
					.attr("y1", (d) => d * cellHeight)
					.attr("y2", (d) => d * cellHeight);

				root
					.selectAll("line.grid-line.vertical")
					.data(d3.range(columns))
					.join("line")
					.attr("class", "grid-line vertical")
					.attr("x1", (d) => d * cellWidth)
					.attr("x2", (d) => d * cellWidth)
					.attr("y1", 0)
					.attr("y2", plotHeight);

				const connectionGroup = root.append("g");
				const arrowGroup = root.append("g");
				const nodeGroup = root.append("g");
				const labelGroup = root.append("g");

				function nodeById(id) {
					return nodes.find((node) => node.id === id);
				}

				connectionGroup
					.selectAll("line.connection-line")
					.data(connections)
					.join("line")
					.attr("class", "connection-line")
					.attr("x1", (d) => nodeById(d.source).x)
					.attr("y1", (d) => nodeById(d.source).y)
					.attr("x2", (d) => nodeById(d.target).x)
					.attr("y2", (d) => nodeById(d.target).y);

				arrowGroup
					.selectAll("line.arrow-line")
					.data(arrows.map((arrow, index) => ({ ...arrow, markerId: `arrow-head-${index}` })))
					.join("line")
					.attr("class", "arrow-line")
					.attr("stroke", (d) => d.color)
					.attr("marker-end", (d) => `url(#${d.markerId})`)
					.attr("x1", (d) => nodeById(d.source).x)
					.attr("y1", (d) => nodeById(d.source).y)
					.attr("x2", (d) => nodeById(d.target).x)
					.attr("y2", (d) => nodeById(d.target).y);

				const nodeElements = nodeGroup
					.selectAll("circle.grid-node")
					.data(nodes)
					.join("circle")
					.attr("class", "grid-node")
					.attr("r", 9)
					.attr("cx", plotWidth / 2)
					.attr("cy", -40)
					.each(function (d) {
						d.finalX = d.x;
						d.finalY = d.y;
					});

				const labelElements = labelGroup
					.selectAll("text.grid-label")
					.data(nodes)
					.join("text")
					.attr("class", "grid-label")
					.attr("x", (d) => d.x + 14)
					.attr("y", (d) => d.y - 12)
					.text((d) => d.label)
					.style("opacity", 0);

				const enhancedNodes = nodeGroup.selectAll("circle.grid-node");

				function setActive(id) {
					enhancedNodes.classed("active", (d) => d.id === id);
					labelGroup.selectAll("text.grid-label").classed("active", (d) => d.id === id);
					connectionGroup
						.selectAll("line.connection-line")
						.classed("active", (d) => d.source === id || d.target === id);
				}

				function resetActive() {
					enhancedNodes.classed("active", false);
					labelGroup.selectAll("text.grid-label").classed("active", false);
					connectionGroup.selectAll("line.connection-line").classed("active", false);
				}

				enhancedNodes
					.on("mouseenter", (_, d) => setActive(d.id))
					.on("mouseleave", resetActive)
					.on("focus", (_, d) => setActive(d.id))
					.on("blur", resetActive)
					.attr("tabindex", 0)
					.append("title")
					.text((d) => d.label);

				function playAnimation(progress) {
					const eased = d3.easeCubicOut(progress);
					nodeElements
						.attr("cx", (d) => (1 - eased) * (plotWidth / 2) + eased * d.finalX)
						.attr("cy", (d) => (1 - eased) * -40 + eased * d.finalY);

					labelElements.style("opacity", Math.max(0, Math.min(1, eased)));
				}

				const observer = new IntersectionObserver(
					(entries) => {
						entries.forEach((entry) => {
							const startThreshold = 0.25;
							const ratio = entry.intersectionRatio || 0;
							const adjustedProgress = Math.max(0, Math.min(1, (ratio - startThreshold) / (1 - startThreshold)));
							playAnimation(adjustedProgress);
							if (adjustedProgress >= 1) {
								observer.unobserve(entry.target);
							}
						});
					},
					{
						root: null,
						rootMargin: "0px",
						threshold: Array.from({ length: 21 }, (_, i) => i / 20)
					}
				);

				observer.observe(document.querySelector("#grid-chart"));
			})();

				(function () {
					const frame = document.querySelector(".doodle-frame");
					const svg = d3.select("#doodle-chart");
					if (!frame || svg.empty()) return;

					frame.style.transform = "translateX(35%)";
					frame.style.opacity = "0";

					const slideObserver = new IntersectionObserver(
						(entries) => {
							entries.forEach((entry) => {
								const start = 0.2;
								const ratio = entry.intersectionRatio || 0;
								const progress = Math.max(0, Math.min(1, (ratio - start) / (1 - start)));
								const translate = (1 - progress) * 35;
								frame.style.transform = `translateX(${translate}%)`;
								frame.style.opacity = progress.toFixed(3);
								if (progress >= 1) {
									slideObserver.unobserve(entry.target);
								}
							});
						},
						{
							threshold: Array.from({ length: 21 }, (_, i) => i / 20)
						}
					);

					slideObserver.observe(frame);

					svg.attr("viewBox", "0 0 360 360").attr("preserveAspectRatio", "xMidYMid meet");
					const root = svg.append("g").attr("transform", "translate(20,20)");

					const strokeColor = "#0f172a";
					const colors = ["#facc15", "#f97316"];

					const body = root
						.append("rect")
						.attr("class", "fillable-region")
						.attr("x", 60)
						.attr("y", 20)
						.attr("width", 220)
						.attr("height", 250)
						.attr("rx", 24)
						.attr("ry", 24)
						.attr("fill", "#ffffff")
						.attr("stroke", strokeColor)
						.attr("stroke-width", 6)
						.attr("vector-effect", "non-scaling-stroke");

					root
						.append("path")
						.attr("d", "M60,120 C20,90 20,60 40,50")
						.attr("fill", "none")
						.attr("stroke", strokeColor)
						.attr("stroke-width", 6)
						.attr("stroke-linecap", "round")
						.attr("vector-effect", "non-scaling-stroke");

					root
						.append("path")
						.attr("d", "M280,120 C320,100 330,70 300,60")
						.attr("fill", "none")
						.attr("stroke", strokeColor)
						.attr("stroke-width", 6)
						.attr("stroke-linecap", "round")
						.attr("vector-effect", "non-scaling-stroke");

					root
						.append("path")
						.attr("d", "M120,270 L110,320")
						.attr("fill", "none")
						.attr("stroke", strokeColor)
						.attr("stroke-width", 6)
						.attr("stroke-linecap", "round")
						.attr("vector-effect", "non-scaling-stroke");

					root
						.append("path")
						.attr("d", "M220,270 L230,320")
						.attr("fill", "none")
						.attr("stroke", strokeColor)
						.attr("stroke-width", 6)
						.attr("stroke-linecap", "round")
						.attr("vector-effect", "non-scaling-stroke");

					const leftEye = root
						.append("rect")
						.attr("class", "fillable-region")
						.attr("x", 100)
						.attr("y", 80)
						.attr("width", 60)
						.attr("height", 42)
						.attr("rx", 10)
						.attr("ry", 10)
						.attr("fill", "#ffffff")
						.attr("stroke", strokeColor)
						.attr("stroke-width", 5)
						.attr("vector-effect", "non-scaling-stroke");

					const rightEye = root
						.append("rect")
						.attr("class", "fillable-region")
						.attr("x", 200)
						.attr("y", 76)
						.attr("width", 64)
						.attr("height", 46)
						.attr("rx", 12)
						.attr("ry", 12)
						.attr("fill", "#ffffff")
						.attr("stroke", strokeColor)
						.attr("stroke-width", 5)
						.attr("vector-effect", "non-scaling-stroke");

					root
						.append("circle")
						.attr("cx", 130)
						.attr("cy", 100)
						.attr("r", 12)
						.attr("fill", strokeColor);

					root
						.append("circle")
						.attr("cx", 232)
						.attr("cy", 98)
						.attr("r", 12)
						.attr("fill", strokeColor);

					root
						.append("path")
						.attr("d", "M170,140 L166,150 L178,150 Z")
						.attr("fill", strokeColor);

					const mouth = root
						.append("rect")
						.attr("class", "fillable-region")
						.attr("x", 120)
						.attr("y", 172)
						.attr("width", 130)
						.attr("height", 60)
						.attr("rx", 14)
						.attr("ry", 14)
						.attr("fill", "#ffffff")
						.attr("stroke", strokeColor)
						.attr("stroke-width", 5)
						.attr("vector-effect", "non-scaling-stroke");

					root
						.append("path")
						.attr("d", "M132,202 H 238")
						.attr("fill", "none")
						.attr("stroke", strokeColor)
						.attr("stroke-width", 5)
						.attr("vector-effect", "non-scaling-stroke");

					root
						.append("path")
						.attr("d", "M170,172 V 232")
						.attr("fill", "none")
						.attr("stroke", strokeColor)
						.attr("stroke-width", 5)
						.attr("vector-effect", "non-scaling-stroke");

					root
						.append("path")
						.attr("d", "M210,172 V 232")
						.attr("fill", "none")
						.attr("stroke", strokeColor)
						.attr("stroke-width", 5)
						.attr("vector-effect", "non-scaling-stroke");

					const teeth = [
						{ x: 140, y: 188 },
						{ x: 192, y: 188 }
					];

					teeth.forEach((pos) => {
						root
							.append("rect")
							.attr("class", "fillable-region")
							.attr("x", pos.x)
							.attr("y", pos.y)
							.attr("width", 28)
							.attr("height", 20)
							.attr("rx", 6)
							.attr("ry", 6)
							.attr("fill", "#ffffff")
							.attr("stroke", strokeColor)
							.attr("stroke-width", 4)
							.attr("vector-effect", "non-scaling-stroke");
					});

					const fillableSelection = root.selectAll(".fillable-region");

					function paint(selection) {
						const color = colors[Math.floor(Math.random() * colors.length)];
						selection.attr("fill", color);
					}

					fillableSelection
						.attr("tabindex", 0)
						.on("click", function (event) {
							paint(d3.select(this));
						})
						.on("keydown", function (event) {
							if (event.key === "Enter" || event.key === " ") {
								event.preventDefault();
								paint(d3.select(this));
							}
						});

					fillableSelection.append("title").text("Click to recolor");
				})();
		</script>
	</body>
</html>
