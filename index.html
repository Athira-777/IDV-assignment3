<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Sports Search Trends</title>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
				background: #ffffff;
				color: #1f2937;
				font-family: "Inter", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
			}

			body {
				display: flex;
				align-items: center;
				justify-content: center;
				padding: clamp(1rem, 3vw, 2rem);
			}

			#chart {
				width: min(1400px, 98vw);
				height: min(680px, 88vh);
				display: block;
			}

			.axis path,
			.axis line {
				stroke: rgba(148, 163, 184, 0.4);
			}

			.axis text {
				fill: #334155;
				font-size: 0.85rem;
			}

			.axis-label {
				fill: #475569;
				font-size: 0.9rem;
				letter-spacing: 0.04em;
			}

			.line {
				fill: none;
				stroke-linejoin: round;
				stroke-linecap: round;
				stroke-width: 1.8;
				stroke-opacity: 0.9;
				transition: stroke-opacity 0.2s ease, stroke-width 0.2s ease;
			}

			.area {
				stroke: none;
				fill-opacity: 0;
				transition: fill-opacity 0.2s ease;
			}

			.legend text {
				fill: #1f2937;
				font-size: 0.95rem;
				cursor: pointer;
				transition: fill 0.2s ease;
			}

			.legend text:hover,
			.legend text:focus-visible {
				fill: #0f172a;
			}

			.legend-line {
				stroke-width: 3;
				stroke-linecap: round;
			}

			.legend-item {
				outline: none;
			}

			.hover-target {
				fill: none;
				stroke: transparent;
				stroke-width: 24;
				cursor: pointer;
			}
		</style>
	</head>
	<body>
        <!-- 
        My initial prompt was: 
        Make a histogram using HTML, CSS, D3.JS that will get posted online through github actions. sportsdata.csv has the data that must be used.

        This took a very long time to load and provided a complicated graph with too much data, hence I added a new prompt to edit the existing code and remove unneccessary details.) I just need a chart that includes all of the data sets (f1, nba, nfll, premierLeague) instead of a bar chart, do a line chart that becomes an area graph when you hover the cursor over the specific data set. Do not add extra text, just keep the graph and its axis and data set
        -->

		<svg id="chart" role="img" aria-label="Weekly search interest by league"></svg>

		<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
		<script>
			(function () {
				const svg = d3.select("#chart");
				const width = 1300;
				const height = 640;
				const margin = { top: 64, right: 220, bottom: 80, left: 72 };
				const plotWidth = width - margin.left - margin.right;
				const plotHeight = height - margin.top - margin.bottom;

				const parseDate = d3.timeParse("%Y-%m-%d");

				const seriesDefinitions = [
					{ key: "f1", label: "F1", column: "f1: (Worldwide)" },
					{ key: "nba", label: "NBA", column: "nba: (Worldwide)" },
					{ key: "nfl", label: "NFL", column: "nfl: (Worldwide)" },
					{ key: "premierLeague", label: "Premier League", column: "Premier League: (Worldwide)" }
				];

				const parseValue = (value) => {
					const numeric = Number(value);
					return Number.isFinite(numeric) ? numeric : NaN;
				};

				const color = d3
					.scaleOrdinal()
					.domain(seriesDefinitions.map((d) => d.key))
					.range(["#1f77b4", "#d62728", "#2ca02c", "#ff7f0e"]);

				const definedValue = (d) => Number.isFinite(d.value);

				svg.attr("viewBox", `0 0 ${width} ${height}`).attr("preserveAspectRatio", "xMidYMid meet");

				const root = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

				const xScale = d3.scaleTime().range([0, plotWidth]);
				const yScale = d3.scaleLinear().range([plotHeight, 0]);

				const lineBuilder = d3
					.line()
					.defined(definedValue)
					.x((d) => xScale(d.date))
					.y((d) => yScale(d.value));

				const areaBuilder = d3
					.area()
					.defined(definedValue)
					.x((d) => xScale(d.date))
					.y0(plotHeight)
					.y1((d) => yScale(d.value));

				const areasLayer = root.append("g");
				const linesLayer = root.append("g");
				const hitLayer = root.append("g");

				const xAxisGroup = root
					.append("g")
					.attr("class", "axis axis--x")
					.attr("transform", `translate(0,${plotHeight})`);

				const yAxisGroup = root.append("g").attr("class", "axis axis--y");

				root
					.append("text")
					.attr("class", "axis-label")
					.attr("x", plotWidth / 2)
					.attr("y", plotHeight + margin.bottom - 28)
					.attr("text-anchor", "middle")
					.text("Week");

				root
					.append("text")
					.attr("class", "axis-label")
					.attr("x", -margin.left + 18)
					.attr("y", -28)
					.attr("text-anchor", "start")
					.text("Search interest");

				const legend = svg
					.append("g")
					.attr("class", "legend")
					.attr("transform", `translate(${width - margin.right + 30},${margin.top})`);

				let areaPaths;
				let linePaths;

				function cleanCsvLines(rawText) {
					const lines = rawText.split(/\r?\n/).filter((line) => line.trim().length > 0);
					const headerIndex = lines.findIndex((line) => line.startsWith("Week,"));
					if (headerIndex === -1) {
						throw new Error("Unable to locate CSV header in sportsdata.csv");
					}
					return lines.slice(headerIndex).join("\n");
				}

				function setActiveSeries(key) {
					if (!linePaths || !areaPaths) return;
					const hasKey = Boolean(key);
					linePaths
						.attr("stroke-opacity", (d) => (hasKey && d.key !== key ? 0.25 : 0.95))
						.attr("stroke-width", (d) => (hasKey && d.key === key ? 2.7 : 1.8));
					areaPaths.style("fill-opacity", (d) => (hasKey && d.key === key ? 0.4 : 0));
				}

				function resetActiveSeries() {
					setActiveSeries(null);
				}

				function handleLegendKeyboard(event, key) {
					if (event.key === "Enter" || event.key === " ") {
						event.preventDefault();
						setActiveSeries(key);
					} else if (event.key === "Escape") {
						resetActiveSeries();
					}
				}

				d3.text("sportsdata.csv")
					.then((rawText) => {
						const cleanCsv = cleanCsvLines(rawText);
						const parsedRows = d3
							.csvParse(cleanCsv, (row) => ({
								Week: parseDate(row.Week.trim()),
								"f1: (Worldwide)": parseValue(row["f1: (Worldwide)"]),
								"nba: (Worldwide)": parseValue(row["nba: (Worldwide)"]),
								"nfl: (Worldwide)": parseValue(row["nfl: (Worldwide)"]),
								"Premier League: (Worldwide)": parseValue(row["Premier League: (Worldwide)"])
							}))
							.filter((row) => row.Week instanceof Date && !Number.isNaN(row.Week.getTime()));

						if (!parsedRows.length) {
							return;
						}

						const seriesData = seriesDefinitions.map((definition) => ({
							...definition,
							values: parsedRows.map((row) => ({
								date: row.Week,
								value: Number.isFinite(row[definition.column]) ? row[definition.column] : NaN
							}))
						}));

						const xDomain = d3.extent(parsedRows, (d) => d.Week);
						xScale.domain(xDomain);

						const allValues = seriesData
							.flatMap((series) => series.values.map((d) => d.value))
							.filter((value) => Number.isFinite(value));
						const yMax = d3.max(allValues) || 1;
						yScale.domain([0, yMax]).nice();

						const xAxis = d3
							.axisBottom(xScale)
							.ticks(Math.min(12, Math.ceil(parsedRows.length / 8)))
							.tickSizeOuter(0);
						const yAxis = d3.axisLeft(yScale).ticks(6).tickSizeOuter(0);

						xAxisGroup.call(xAxis);
						yAxisGroup.call(yAxis);

						areaPaths = areasLayer
							.selectAll("path.area")
							.data(seriesData, (d) => d.key)
							.join("path")
							.attr("class", "area")
							.attr("fill", (d) => color(d.key))
							.attr("d", (d) => areaBuilder(d.values));

						linePaths = linesLayer
							.selectAll("path.line")
							.data(seriesData, (d) => d.key)
							.join("path")
							.attr("class", "line")
							.attr("stroke", (d) => color(d.key))
							.attr("d", (d) => lineBuilder(d.values));

						hitLayer
							.selectAll("path.hover-target")
							.data(seriesData, (d) => d.key)
							.join("path")
							.attr("class", "hover-target")
							.attr("d", (d) => lineBuilder(d.values))
							.attr("tabindex", 0)
							.on("mouseenter focus", (event, d) => setActiveSeries(d.key))
							.on("mouseleave blur", resetActiveSeries)
							.on("keydown", (event, d) => handleLegendKeyboard(event, d.key));

						const legendItems = legend
							.selectAll("g.legend-item")
							.data(seriesData, (d) => d.key)
							.join((enter) => {
								const g = enter
									.append("g")
									.attr("class", "legend-item")
									.attr("tabindex", 0);

								g.append("line")
									.attr("class", "legend-line")
									.attr("x1", 0)
									.attr("x2", 28)
									.attr("y1", 0)
									.attr("y2", 0);

								g.append("text")
									.attr("x", 36)
									.attr("y", 0)
									.attr("dominant-baseline", "middle");

								return g;
							});

						legendItems
							.attr("transform", (d, i) => `translate(0, ${i * 28})`)
							.select("line.legend-line")
							.attr("stroke", (d) => color(d.key));

						legendItems
							.select("text")
							.text((d) => d.label);

						legendItems
							.on("mouseenter focus", (event, d) => setActiveSeries(d.key))
							.on("mouseleave blur", resetActiveSeries)
							.on("keydown", (event, d) => handleLegendKeyboard(event, d.key));

						resetActiveSeries();
						svg.on("mouseleave", resetActiveSeries);
					})
					.catch((error) => {
						console.error(error);
					});
			})();
		</script>
	</body>
</html>
