<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Sports Search Trends</title>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
				background: #ffffff;
				color: #1f2937;
				font-family: "Inter", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
			}

			body {
				display: flex;
				justify-content: center;
				padding: clamp(2rem, 5vw, 4rem) clamp(1.5rem, 4vw, 3rem);
				background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
			}

			.page {
				width: min(1400px, 98vw);
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: clamp(3rem, 6vw, 5rem);
			}

			.chart-frame {
				width: 100%;
				background: #f9fafb;
				border: 1px solid #e2e8f0;
				box-shadow: 0 12px 28px rgba(15, 23, 42, 0.08);
				padding: clamp(1rem, 3vw, 1.5rem);
				border-radius: 18px;
			}

			.chart-frame svg {
				width: 100%;
				display: block;
			}

			#line-chart {
				height: min(680px, 80vh);
			}

			#grid-chart {
				height: min(420px, 60vh);
			}

			.axis path,
			.axis line {
				stroke: rgba(148, 163, 184, 0.4);
			}

			.axis text {
				fill: #334155;
				font-size: 0.85rem;
			}

			.axis-label {
				fill: #475569;
				font-size: 0.9rem;
				letter-spacing: 0.04em;
			}

			.line {
				fill: none;
				stroke-linejoin: round;
				stroke-linecap: round;
				stroke-width: 1.8;
				stroke-opacity: 0.9;
				transition: stroke-opacity 0.2s ease, stroke-width 0.2s ease;
			}

			.area {
				stroke: none;
				fill-opacity: 0;
				transition: fill-opacity 0.2s ease;
			}

			.legend text {
				fill: #1f2937;
				font-size: 0.95rem;
				cursor: pointer;
				transition: fill 0.2s ease;
			}

			.legend text:hover,
			.legend text:focus-visible {
				fill: #0f172a;
			}

			.legend-line {
				stroke-width: 3;
				stroke-linecap: round;
			}

			.legend-item {
				outline: none;
			}

			.hover-target {
				fill: none;
				stroke: transparent;
				stroke-width: 24;
				cursor: pointer;
			}

			.grid-line {
				stroke: rgba(148, 163, 184, 0.35);
				stroke-width: 1;
			}

			.connection-line {
				stroke: #111827;
				stroke-width: 2;
				stroke-linecap: round;
			}

			.connection-line.active {
				stroke-width: 3.5;
			}

			.arrow-line {
				fill: none;
				stroke-width: 2.5;
				stroke-dasharray: 8 6;
			}

			.grid-node {
				fill: #2563eb;
				stroke: #0f172a;
				stroke-width: 2;
				transition: transform 0.2s ease, fill 0.2s ease;
				cursor: pointer;
			}

			.grid-node.active {
				fill: #1d4ed8;
				transform: scale(1.1);
			}

			.grid-label {
				fill: #1f2937;
				font-weight: 600;
				font-size: 0.9rem;
			}

			.grid-label.active {
				fill: #1d4ed8;
			}
		</style>
	</head>
	<body>
		<div class="page">
			<div class="chart-frame">
				<svg id="line-chart" role="img" aria-label="Weekly search interest by league"></svg>
			</div>
			<div class="chart-frame">
				<svg
					id="grid-chart"
					role="img"
					aria-label="Grid network view of energy states"
				></svg>
			</div>
		</div>

		<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
		<script>
			/* 
			My initial prompt was: 
			Make a histogram using HTML, CSS, D3.JS that will get posted online through github actions. sportsdata.csv has the data that must be used.
			This took a very long time to load and provided a complicated graph with too much data, hence I added a new prompt to edit the existing code and remove unneccessary details.):
            I just need a chart that includes all of the data sets (f1, nba, nfll, premierLeague) instead of a bar chart, do a line chart that becomes an area graph when you hover the cursor over the specific data set. Do not add extra text, just keep the graph and its axis and data set
			*/
			(function () {
				const svg = d3.select("#line-chart");
				const width = 1300;
				const height = 640;
				const margin = { top: 64, right: 220, bottom: 80, left: 72 };
				const plotWidth = width - margin.left - margin.right;
				const plotHeight = height - margin.top - margin.bottom;

				const parseDate = d3.timeParse("%Y-%m-%d");

				const seriesDefinitions = [
					{ key: "f1", label: "F1", column: "f1: (Worldwide)" },
					{ key: "nba", label: "NBA", column: "nba: (Worldwide)" },
					{ key: "nfl", label: "NFL", column: "nfl: (Worldwide)" },
					{ key: "premierLeague", label: "Premier League", column: "Premier League: (Worldwide)" }
				];

				const parseValue = (value) => {
					const numeric = Number(value);
					return Number.isFinite(numeric) ? numeric : NaN;
				};

				const color = d3
					.scaleOrdinal()
					.domain(seriesDefinitions.map((d) => d.key))
					.range(["#1f77b4", "#d62728", "#2ca02c", "#ff7f0e"]);

				const definedValue = (d) => Number.isFinite(d.value);

				svg.attr("viewBox", `0 0 ${width} ${height}`).attr("preserveAspectRatio", "xMidYMid meet");

				const root = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

				const xScale = d3.scaleTime().range([0, plotWidth]);
				const yScale = d3.scaleLinear().range([plotHeight, 0]);

				const lineBuilder = d3
					.line()
					.defined(definedValue)
					.x((d) => xScale(d.date))
					.y((d) => yScale(d.value));

				const areaBuilder = d3
					.area()
					.defined(definedValue)
					.x((d) => xScale(d.date))
					.y0(plotHeight)
					.y1((d) => yScale(d.value));

				const areasLayer = root.append("g");
				const linesLayer = root.append("g");
				const hitLayer = root.append("g");

				const xAxisGroup = root
					.append("g")
					.attr("class", "axis axis--x")
					.attr("transform", `translate(0,${plotHeight})`);

				const yAxisGroup = root.append("g").attr("class", "axis axis--y");

				root
					.append("text")
					.attr("class", "axis-label")
					.attr("x", plotWidth / 2)
					.attr("y", plotHeight + margin.bottom - 28)
					.attr("text-anchor", "middle")
					.text("Week");

				root
					.append("text")
					.attr("class", "axis-label")
					.attr("x", -margin.left + 18)
					.attr("y", -28)
					.attr("text-anchor", "start")
					.text("Search interest");

				const legend = svg
					.append("g")
					.attr("class", "legend")
					.attr("transform", `translate(${width - margin.right + 30},${margin.top})`);

				let areaPaths;
				let linePaths;

				function cleanCsvLines(rawText) {
					const lines = rawText.split(/\r?\n/).filter((line) => line.trim().length > 0);
					const headerIndex = lines.findIndex((line) => line.startsWith("Week,"));
					if (headerIndex === -1) {
						throw new Error("Unable to locate CSV header in sportsdata.csv");
					}
					return lines.slice(headerIndex).join("\n");
				}

				function setActiveSeries(key) {
					if (!linePaths || !areaPaths) return;
					const hasKey = Boolean(key);
					linePaths
						.attr("stroke-opacity", (d) => (hasKey && d.key !== key ? 0.25 : 0.95))
						.attr("stroke-width", (d) => (hasKey && d.key === key ? 2.7 : 1.8));
					areaPaths.style("fill-opacity", (d) => (hasKey && d.key === key ? 0.4 : 0));
				}

				function resetActiveSeries() {
					setActiveSeries(null);
				}

				function handleLegendKeyboard(event, key) {
					if (event.key === "Enter" || event.key === " ") {
						event.preventDefault();
						setActiveSeries(key);
					} else if (event.key === "Escape") {
						resetActiveSeries();
					}
				}

				d3.text("sportsdata.csv")
					.then((rawText) => {
						const cleanCsv = cleanCsvLines(rawText);
						const parsedRows = d3
							.csvParse(cleanCsv, (row) => ({
								Week: parseDate(row.Week.trim()),
								"f1: (Worldwide)": parseValue(row["f1: (Worldwide)"]),
								"nba: (Worldwide)": parseValue(row["nba: (Worldwide)"]),
								"nfl: (Worldwide)": parseValue(row["nfl: (Worldwide)"]),
								"Premier League: (Worldwide)": parseValue(row["Premier League: (Worldwide)"])
							}))
							.filter((row) => row.Week instanceof Date && !Number.isNaN(row.Week.getTime()));

						if (!parsedRows.length) {
							return;
						}

						const seriesData = seriesDefinitions.map((definition) => ({
							...definition,
							values: parsedRows.map((row) => ({
								date: row.Week,
								value: Number.isFinite(row[definition.column]) ? row[definition.column] : NaN
							}))
						}));

						const xDomain = d3.extent(parsedRows, (d) => d.Week);
						xScale.domain(xDomain);

						const allValues = seriesData
							.flatMap((series) => series.values.map((d) => d.value))
							.filter((value) => Number.isFinite(value));
						const yMax = d3.max(allValues) || 1;
						yScale.domain([0, yMax]).nice();

						const xAxis = d3
							.axisBottom(xScale)
							.ticks(Math.min(12, Math.ceil(parsedRows.length / 8)))
							.tickSizeOuter(0);
						const yAxis = d3.axisLeft(yScale).ticks(6).tickSizeOuter(0);

						xAxisGroup.call(xAxis);
						yAxisGroup.call(yAxis);

						areaPaths = areasLayer
							.selectAll("path.area")
							.data(seriesData, (d) => d.key)
							.join("path")
							.attr("class", "area")
							.attr("fill", (d) => color(d.key))
							.attr("d", (d) => areaBuilder(d.values));

						linePaths = linesLayer
							.selectAll("path.line")
							.data(seriesData, (d) => d.key)
							.join("path")
							.attr("class", "line")
							.attr("stroke", (d) => color(d.key))
							.attr("d", (d) => lineBuilder(d.values));

						hitLayer
							.selectAll("path.hover-target")
							.data(seriesData, (d) => d.key)
							.join("path")
							.attr("class", "hover-target")
							.attr("d", (d) => lineBuilder(d.values))
							.attr("tabindex", 0)
							.on("mouseenter focus", (event, d) => setActiveSeries(d.key))
							.on("mouseleave blur", resetActiveSeries)
							.on("keydown", (event, d) => handleLegendKeyboard(event, d.key));

						const legendItems = legend
							.selectAll("g.legend-item")
							.data(seriesData, (d) => d.key)
							.join((enter) => {
								const g = enter
									.append("g")
									.attr("class", "legend-item")
									.attr("tabindex", 0);

								g.append("line")
									.attr("class", "legend-line")
									.attr("x1", 0)
									.attr("x2", 28)
									.attr("y1", 0)
									.attr("y2", 0);

								g.append("text")
									.attr("x", 36)
									.attr("y", 0)
									.attr("dominant-baseline", "middle");

								return g;
							});

						legendItems
							.attr("transform", (d, i) => `translate(0, ${i * 28})`)
							.select("line.legend-line")
							.attr("stroke", (d) => color(d.key));

						legendItems
							.select("text")
							.text((d) => d.label);

						legendItems
							.on("mouseenter focus", (event, d) => setActiveSeries(d.key))
							.on("mouseleave blur", resetActiveSeries)
							.on("keydown", (event, d) => handleLegendKeyboard(event, d.key));

						resetActiveSeries();
						svg.on("mouseleave", resetActiveSeries);
					})
					.catch((error) => {
						console.error(error);
					});
			})();
            
			/*
			I spaced out the graphs more like this. also made the transition work better:
			the 2 graphs are too close to each other, causing the transition to activate too early. move the 2 graphs away from each other, and make the transition position dependent - i.e. start when the graph comes in to view and finish when it's fully in view.
			*/

			(function () {
				const columns = 5;
				const rows = 12;
				const width = 1220;
				const height = 400;
				const margin = { top: 36, right: 200, bottom: 42, left: 80 };
				const plotWidth = width - margin.left - margin.right;
				const plotHeight = height - margin.top - margin.bottom;

				const svg = d3
					.select("#grid-chart")
					.attr("viewBox", `0 0 ${width} ${height}`)
					.attr("preserveAspectRatio", "xMidYMid meet");

				const root = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

				const cellWidth = plotWidth / (columns - 1);
				const cellHeight = plotHeight / (rows - 1);

				const nodes = [
					{ id: "ea2", label: "eᵃ₂", col: 2, row: 3 },
					{ id: "ea1", label: "eᵃ₁", col: 2, row: 8 },
					{ id: "eb2", label: "eᵇ₂", col: 4, row: 4 },
					{ id: "eb1", label: "eᵇ₁", col: 4, row: 6 }
				].map((node) => ({
					...node,
					x: (node.col - 1) * cellWidth,
					y: (node.row - 1) * cellHeight
				}));

				const connections = [
					{ source: "ea2", target: "ea1" },
					{ source: "ea2", target: "eb2" },
					{ source: "eb1", target: "ea1" },
					{ source: "eb1", target: "eb2" }
				];

				const arrows = [
					{ source: "ea2", target: "eb1", color: "#60a5fa" },
					{ source: "ea1", target: "eb2", color: "#1e3a8a" }
				];

				const markers = svg.append("defs");

				arrows.forEach((arrow, index) => {
					markers
						.append("marker")
						.attr("id", `arrow-head-${index}`)
						.attr("viewBox", "0 -4 8 8")
						.attr("refX", 8)
						.attr("refY", 0)
						.attr("markerWidth", 8)
						.attr("markerHeight", 8)
						.attr("orient", "auto")
						.append("path")
						.attr("d", "M0,-4L8,0L0,4")
						.attr("fill", arrow.color);
				});

				root
					.selectAll("line.grid-line.horizontal")
					.data(d3.range(rows))
					.join("line")
					.attr("class", "grid-line horizontal")
					.attr("x1", 0)
					.attr("x2", plotWidth)
					.attr("y1", (d) => d * cellHeight)
					.attr("y2", (d) => d * cellHeight);

				root
					.selectAll("line.grid-line.vertical")
					.data(d3.range(columns))
					.join("line")
					.attr("class", "grid-line vertical")
					.attr("x1", (d) => d * cellWidth)
					.attr("x2", (d) => d * cellWidth)
					.attr("y1", 0)
					.attr("y2", plotHeight);

				const connectionGroup = root.append("g");
				const arrowGroup = root.append("g");
				const nodeGroup = root.append("g");
				const labelGroup = root.append("g");

				function nodeById(id) {
					return nodes.find((node) => node.id === id);
				}

				connectionGroup
					.selectAll("line.connection-line")
					.data(connections)
					.join("line")
					.attr("class", "connection-line")
					.attr("x1", (d) => nodeById(d.source).x)
					.attr("y1", (d) => nodeById(d.source).y)
					.attr("x2", (d) => nodeById(d.target).x)
					.attr("y2", (d) => nodeById(d.target).y);

				arrowGroup
					.selectAll("line.arrow-line")
					.data(arrows.map((arrow, index) => ({ ...arrow, markerId: `arrow-head-${index}` })))
					.join("line")
					.attr("class", "arrow-line")
					.attr("stroke", (d) => d.color)
					.attr("marker-end", (d) => `url(#${d.markerId})`)
					.attr("x1", (d) => nodeById(d.source).x)
					.attr("y1", (d) => nodeById(d.source).y)
					.attr("x2", (d) => nodeById(d.target).x)
					.attr("y2", (d) => nodeById(d.target).y);

				const nodeElements = nodeGroup
					.selectAll("circle.grid-node")
					.data(nodes)
					.join("circle")
					.attr("class", "grid-node")
					.attr("r", 9)
					.attr("cx", plotWidth / 2)
					.attr("cy", -40)
					.each(function (d) {
						d.finalX = d.x;
						d.finalY = d.y;
					});

				const labelElements = labelGroup
					.selectAll("text.grid-label")
					.data(nodes)
					.join("text")
					.attr("class", "grid-label")
					.attr("x", (d) => d.x + 14)
					.attr("y", (d) => d.y - 12)
					.text((d) => d.label)
					.style("opacity", 0);

				const enhancedNodes = nodeGroup.selectAll("circle.grid-node");

				function setActive(id) {
					enhancedNodes.classed("active", (d) => d.id === id);
					labelGroup.selectAll("text.grid-label").classed("active", (d) => d.id === id);
					connectionGroup
						.selectAll("line.connection-line")
						.classed("active", (d) => d.source === id || d.target === id);
				}

				function resetActive() {
					enhancedNodes.classed("active", false);
					labelGroup.selectAll("text.grid-label").classed("active", false);
					connectionGroup.selectAll("line.connection-line").classed("active", false);
				}

				enhancedNodes
					.on("mouseenter", (_, d) => setActive(d.id))
					.on("mouseleave", resetActive)
					.on("focus", (_, d) => setActive(d.id))
					.on("blur", resetActive)
					.attr("tabindex", 0)
					.append("title")
					.text((d) => d.label);

				function playAnimation(progress) {
					const eased = d3.easeCubicOut(progress);
					nodeElements
						.attr("cx", (d) => (1 - eased) * (plotWidth / 2) + eased * d.finalX)
						.attr("cy", (d) => (1 - eased) * -40 + eased * d.finalY);

					labelElements.style("opacity", Math.max(0, Math.min(1, eased)));
				}

				const observer = new IntersectionObserver(
					(entries) => {
						entries.forEach((entry) => {
							const { intersectionRect, boundingClientRect } = entry;
							const visibleHeight = Math.max(0, intersectionRect.height || 0);
							const totalHeight = boundingClientRect.height || 1;
							const progress = Math.max(0, Math.min(1, visibleHeight / totalHeight));
							playAnimation(progress);
							if (progress >= 1) {
								observer.unobserve(entry.target);
							}
						});
					},
					{
						root: null,
						rootMargin: "0px",
						threshold: Array.from({ length: 11 }, (_, i) => i / 10)
					}
				);

				observer.observe(document.querySelector("#grid-chart"));
			})();
		</script>
	</body>
</html>
